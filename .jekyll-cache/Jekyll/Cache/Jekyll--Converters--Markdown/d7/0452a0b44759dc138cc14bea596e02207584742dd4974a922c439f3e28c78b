I"ìF<h2 id="question">Question</h2>

<p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Formula</th>
      <th>Series</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Triangle</td>
      <td>\(P_{3,n}=\frac{1}{2}n(n+1)\)</td>
      <td>1, 3, 6, 10, 15, ‚Ä¶</td>
    </tr>
    <tr>
      <td>Square</td>
      <td>\(P_{4,n}=n^2\)</td>
      <td>1, 4, 9, 16, 25, ‚Ä¶</td>
    </tr>
    <tr>
      <td>Pentagonal</td>
      <td>\(P_{5,n}=\frac{1}{2}n(3n-1)\)</td>
      <td>1, 5, 12, 22, 35, ‚Ä¶</td>
    </tr>
    <tr>
      <td>Hexagonal</td>
      <td>\(P_{6,n}=n(2n-1)\)</td>
      <td>1, 6, 15, 28, 45, ‚Ä¶</td>
    </tr>
    <tr>
      <td>Heptagonal</td>
      <td>\(P_{7,n}=\frac{1}{2}n(5n-3)\)</td>
      <td>1, 7, 18, 34, 55, ‚Ä¶</td>
    </tr>
    <tr>
      <td>Octagonal</td>
      <td>\(P_{8,n}=n(3n-2)\)</td>
      <td>1, 8, 21, 40, 65</td>
    </tr>
  </tbody>
</table>

<p>The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.</p>

<ol>
  <li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with first).</li>
  <li>Each polygonal type: triangle (\(P_{3,127}=8128\)), square (\(P_{4,91}=8281\)), and pentagonal (\(P_{5,44}=2882\)), is represented by a different number in the set.</li>
  <li>This is the only set of 4-digit numbers with this property.</li>
</ol>

<p>Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>

<h2 id="answer">Answer</h2>

<p>It is way too inefficient to check every possible set of six of numbers, as there are 6 different types. However, what we can do is create a sort of ‚Äútree‚Äù of possible paths. For instance, suppose we pick the smallest 4-digit octagonal number \(P_{8,19}=1045\). If we assume the <strong>next number in the chain</strong> is heptagonal, then the <strong>only</strong> possible value is \(P_{7,43}=4558\). However, no hexagonal, pentagonal, or square numbers have these last two digits. Only \(P_{3,108}=5886\) can follow. In this way, we can search the remaining sets for numbers that start with ‚Äú86‚Äù. Unfortunately, through eliminating possibilities, you find at that you can add up to two more numbers before the chain breaks and you have to start over again from a different octagonal number.</p>

<p>This continuous eliminating of possibilities is what allows to quickly see if a chain is possible given a starting number. Because this acts like a tree search almost, it lends itself nicely to a <strong>recursive</strong> approach. We can create a list of each type of polygonal numbers, which gets passed into the recursive function. We also have a list of the current chain going as well. Every time we choose a number from a list, we remove it so it doesn‚Äôt get chosen from again.</p>

<p>We can make one key optimization. If a number has a 0 in the third position, then it‚Äôs impossible to form a chain, because that would entail the next number start with a 0.</p>

<ol>
  <li><strong>Base case</strong>: If we have zero choices to make for the next number AND our chain length is 6, then we have found a chain, so return it! Otherwise, this chain is invalid so cut off the tree and stop looking.</li>
  <li>If our chain length is 0, then simply loop through all starting numbers and start the chain up.</li>
  <li><strong>Recursive case</strong>: For each polygonal set, grab all numbers that can be tacked on to our ongoing chain. If it‚Äôs the <strong>last</strong> number, then also look at the first two digits of the first number in the chain list. <strong>Recurse</strong>, with the addition of each valid number, removing the list the number came from in the recursive call.</li>
</ol>

<p>See the recursive function <code class="highlighter-rouge">findCyclicSets</code> below. Additionally, I also have a function <code class="highlighter-rouge">genPolyNums</code> which allows me to generate each set of polygonal numbers.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function to generate polygonal
# numbers up to octogonal, given
# bounds.
</span><span class="k">def</span> <span class="nf">genPolyNums</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="c1"># Generate the lambda function...
</span>    <span class="k">if</span> <span class="n">degree</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">degree</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">degree</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">degree</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">degree</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Increment n until our polygonal
</span>    <span class="c1"># number is bigger than 'low',
</span>    <span class="c1"># then loop until it's bigger than
</span>    <span class="c1"># 'high'.
</span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">low</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">nums</span>

<span class="c1"># Recursive function to generate
# cyclic chains using exactly
# one number from a list of sets.
</span><span class="k">def</span> <span class="nf">findCyclicSets</span><span class="p">(</span><span class="n">numSets</span><span class="p">,</span> <span class="n">currChain</span><span class="p">,</span> <span class="n">chainLength</span><span class="p">):</span>
    <span class="c1"># Base case is when we
</span>    <span class="c1"># have no more numbers to choose from.
</span>    <span class="c1"># If our chain isn't long enough, then
</span>    <span class="c1"># it's failed branch. Otherwise, we return the
</span>    <span class="c1"># chain.
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">currChain</span><span class="p">)</span> <span class="o">==</span> <span class="n">chainLength</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">currChain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="c1"># Recursive cases.
</span>    <span class="c1"># If our currChain is length 0,
</span>    <span class="c1"># start it up by using each number from
</span>    <span class="c1"># the first set.
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">currChain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Skip numbers that have a 0 in
</span>            <span class="c1"># the 3rd position
</span>            <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">findCyclicSets</span><span class="p">(</span><span class="n">numSets</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">chainLength</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
    <span class="c1"># Otherwise, take the last number
</span>    <span class="c1"># in the chain, take each set, and
</span>    <span class="c1"># recurse with the number that forms
</span>    <span class="c1"># a chain. If it's going to be the last
</span>    <span class="c1"># number in the chain, then we have to check the
</span>    <span class="c1"># first number in the chain as well.
</span>    <span class="n">lastTwoDigits</span> <span class="o">=</span> <span class="n">currChain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">100</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numSets</span><span class="p">)):</span>
        <span class="n">numSet</span> <span class="o">=</span> <span class="n">numSets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Filter out numbers that form chain.
</span>        <span class="n">validNums</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numSet</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="n">lastTwoDigits</span><span class="p">]</span>
        <span class="c1"># Filter out numbers that form chain for
</span>        <span class="c1"># the first number IF it's the last number.
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">currChain</span><span class="p">)</span> <span class="o">==</span> <span class="n">chainLength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">firstNumFirstTwo</span> <span class="o">=</span> <span class="n">currChain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">100</span>
            <span class="n">validNums</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">validNums</span> <span class="k">if</span> <span class="n">firstNumFirstTwo</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">100</span><span class="p">]</span>
        <span class="c1"># Recurse using each valid number, removing
</span>        <span class="c1"># the set to prevent future selections from the
</span>        <span class="c1"># set.
</span>        <span class="k">for</span> <span class="n">valid</span> <span class="ow">in</span> <span class="n">validNums</span><span class="p">:</span>
            <span class="c1"># Don't bother checking ones that
</span>            <span class="c1"># have a zero as the second to last digit.
</span>            <span class="k">if</span> <span class="n">valid</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Recurse, making sure to not include this set.
</span>            <span class="n">result</span> <span class="o">=</span> <span class="n">findCyclicSets</span><span class="p">(</span><span class="n">numSets</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">numSets</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">currChain</span> <span class="o">+</span> <span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">chainLength</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

</code></pre></div></div>

<p>At this point, we can generate the polygonal numbers and call the recursive function given the starting conditions of an empty list and chain length of 0.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Generate triangle through octogonal
# numbers...
</span><span class="n">polyNums</span> <span class="o">=</span> <span class="p">[</span><span class="n">genPolyNums</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">cyclicSet</span> <span class="o">=</span> <span class="n">findCyclicSets</span><span class="p">(</span><span class="n">polyNums</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cyclicSet</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">cyclicSet</span><span class="p">))</span>
</code></pre></div></div>

<p>Running the function results in an output of,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1281, 8128, 2882, 8256, 5625, 2512]
28684
0.0008549132425034104 seconds.
</code></pre></div></div>

<p>Therefore, the chain goes 1281, 8128, 2882, 8256, 5625, and 2512. The sum of these numbers is <strong>28684</strong>.</p>
:ET