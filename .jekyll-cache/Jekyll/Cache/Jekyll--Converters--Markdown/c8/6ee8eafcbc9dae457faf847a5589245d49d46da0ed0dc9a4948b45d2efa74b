I"µ<h2 id="question">Question</h2>

<p>It is possible to write ten as the sum of primes in exactly five different ways:</p>

\[\begin{aligned}
&amp;7+3
\\
&amp;5+5
\\
&amp;5+3+2
\\
&amp;3+3+2+2
\\
&amp;2+2+2+2+2
\end{aligned}\]

<p>What is the first value which can be written as the sum of primes in over five thousand different ways?</p>

<h2 id="answer">Answer</h2>

<p>Like with <a href="/ProjectEuler/ProjectEuler/Problem-76-Counting-summations/">previous problem</a>, I researched for a possible recursive definition when using only prime numbers. Thankfully, <a href="https://math.stackexchange.com/a/89661">this Math StackExchange post</a> shows a way to do it. The reason why it works is based on Euler transformations, which are an advanced math topic that is too out of scope to cover here. Please read the post if you are interested!</p>

<p>Essentially, the number of partitions \(\kappa(n)\) for a number \(n\) where each partition consists of only prime numbers is given by</p>

\[\kappa(n) = \frac{1}{n}\left(\text{sopf}(n) + \sum_{j=1}^{n-1}\text{sopf}(n)\kappa(n-j)\right)\]

<p>where \(\kappa(1) = 0\). The function \(\text{sopf}(n)\) is the <strong>sum of prime factors</strong> function, which is the sum of the <strong>distinct</strong> prime factors of \(n\).</p>

<p>Due to the explosion in the answer to the regular partitions, I wager \(n\) would not get too big, and we donâ€™t need to do anything fancy. Instead, we could just loop through each number \(i\) from \(2\) to \(n\). If we encounter an \(i\) that divides into \(n\), then \(i\) is included in the sum of \(\text{sopf}(n)\), and then we <strong>completely</strong> divide it out. This is so the number gets as small as possible as quickly as possible.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sopf</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="c1"># Completely divide out the factor
</span>            <span class="k">while</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">//=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">s</span>
</code></pre></div></div>

<p>As for calculating \(\kappa(n)\) itself, we can use <code class="highlighter-rouge">numpy</code> to reverse the array and multiply them in a single line. In the end, the code looks like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sopfs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">kappas</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">while</span> <span class="n">kappas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">5000</span><span class="p">:</span>
    <span class="n">sopfs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sopf</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">kappas</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">sopfs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sopfs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">kappas</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))))</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kappas</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'is the first value which can be written in 5000+ ways.'</span><span class="p">)</span>
</code></pre></div></div>

<p>The extra 0 in the beginning is so that the index matches the value of \(n\). Running this results in,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>71 is the first value which can be written in 5000+ ways.
0.0018762999999999974 seconds.
</code></pre></div></div>

<p>Thus, as the message says, <strong>71</strong> is the first integer such that there are at least 5000 different ways to write sums.</p>
:ET