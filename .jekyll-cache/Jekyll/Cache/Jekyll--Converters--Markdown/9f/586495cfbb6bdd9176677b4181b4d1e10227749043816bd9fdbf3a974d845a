I"b<h2 id="question">Question</h2>

<p>Let \(p(n)\) represent the number of different ways in which \(n\) coins can be separated into piles. for example, five coins can be separated into piles in exactly seven different ways, so \(p(5)=7\).</p>

<p>[\bigcirc\bigcirc\bigcirc\bigcirc\bigcirc
<br />
\bigcirc\bigcirc\bigcirc\bigcirc\quad\bigcirc
<br />
\bigcirc\bigcirc\bigcirc\quad\bigcirc\bigcirc
<br />
\bigcirc\bigcirc\bigcirc\quad\bigcirc\quad\bigcirc
<br />
\bigcirc\bigcirc\quad\bigcirc\bigcirc\quad\bigcirc
<br />
\bigcirc\bigcirc\quad\bigcirc\quad\bigcirc\quad\bigcirc
<br />
\bigcirc\quad\bigcirc\quad\bigcirc\quad\bigcirc\quad\bigcirc]</p>

<p>Find the least value of \(n\) for which \(p(n)\) is divisible by one million.</p>

<h2 id="answer">Answer</h2>

<p>This is exactly the same problem as <a href="/ProjectEuler/ProjectEuler/Problem-76-Counting-summations/">Problem 76</a>, just worded differently. Notice that since we are counting all the coins as “one pile”, there is no more subtracting one from the answer. Regardless, we can use the same method for generating \(p(n)\). Only difference now is that we append to our partition list as we go along, and our stopping condition is different. Additionally, I have done minor optimizations, such as reducing the number of computations we need to do per loop to try and make it as fast as possible.</p>

<p>One key optimization is that since \(p(n)\) is calculated though a summation, we are checking to see if \(p(n)\mod 1000000 \equiv 0\), and modulus distributes through sums, we don’t have to store massive values of \(p(n)\) and instead can store \(p(n)\mod 1000000\). This will reduce the size of the numbers we add.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">partitions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">pent</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">partitions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">currP</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pentk</span> <span class="o">=</span> <span class="n">pent</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pentk</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">currP</span> <span class="o">=</span> <span class="p">(</span><span class="n">currP</span> <span class="o">+</span> <span class="n">partitions</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">pentk</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="mi">1000000</span>
        <span class="c1"># If k is positive, then it turns into
</span>        <span class="c1"># its negative counterpart,
</span>        <span class="c1"># Otherwise, it goes to the next number
</span>        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">pentk</span> <span class="o">=</span> <span class="n">pent</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># Append...
</span>    <span class="n">partitions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">currP</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="s">'n ='</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'is when p(n) is divisible by 1000000.'</span><span class="p">)</span>
</code></pre></div></div>

<p>Again, due to storing \(p(0)\), we subtract one from the length of our list. The output of the above is,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n = 55374 is when p(n) is divisible by 1000000.
16.1984474 seconds.
</code></pre></div></div>

<p>Thus, <strong>55374</strong> coins is the fewest number needed such that the number of ways of splitting into piles is divisible by one million. The time is satisfactory, given the size of the problem (I don’t want to think about the <em>actual</em> size of \(p(55374)\)). There could be additional steps we can take to minimize the size of the list we are storing.</p>
:ET