I")<h2 id="question">Question</h2>

<p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p>

<p>Find the sum of all primes below two million.</p>

<h2 id="answer">Answer</h2>

<p>Since finding primes is the main crux of this problem, I will refrain from using <code class="highlighter-rouge">primesieve</code> in the problem. In that case, we can turn to our trusty <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>. Essentially, this sieve goes through each number, and crosses off all multiples of that number, excluding itself. The consequence, is that numbers that never get crossed off had no factors, and therefore, are prime. We can easily adapt it to this problem using <code class="highlighter-rouge">numpy</code> functions, and using a <code class="highlighter-rouge">boolean</code> array to represent the sieve:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">2000000</span>
<span class="n">primes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="c1"># Assume all numbers are composite,
# except for 0 and 1
</span><span class="n">primes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">primes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># Only need to check until sqrt(n)
</span><span class="k">while</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
    <span class="c1"># Check to see if it's prime.
</span>    <span class="c1"># If it is, then update multiples
</span>    <span class="c1"># until the end
</span>    <span class="k">if</span> <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">primes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">p</span> <span class="o">+=</span> <span class="n">i</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c1"># Doing np.where will
# get the index values
</span><span class="n">primeValues</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">primes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">primeValues</span><span class="p">))</span>
</code></pre></div></div>

<p>Running the above results in,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>142913828922
1.0929866437847455 seconds.
</code></pre></div></div>

<p>Thus, <strong>142913828922</strong> is our answer. The timing is not that bad either, considering the large bound of two million.</p>
:ET