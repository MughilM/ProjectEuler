I"wn<h2 id="question">Question</h2>

<p>Su Doku (Japanese meaning <em>number place</em>) is the name given to a popular puzzle concept. Its origin is unclear, but credit must be attributed to Leonhard Euler who invented a similar, and much more difficult, puzzle idea called Latin Squares. The objective of Su Doku puzzles, however, is to replace the blanks (or zeros) in a 9 by 9 grid in such that each row, column, and 3 by 3 box contains each of the digits 1 to 9. Below is an example of a typical starting puzzle grid and its solution grid.</p>

<div style="text-align:center;">
<table border="0" cellpadding="0" cellspacing="0" align="center"><tbody><tr><td>
<table cellpadding="5" cellspacing="0" border="1"><tbody><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">0 0 3<br />9 0 0<br />0 0 1</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">0 2 0<br />3 0 5<br />8 0 6</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">6 0 0<br />0 0 1<br />4 0 0</td>
</tr><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">0 0 8<br />7 0 0<br />0 0 6</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">1 0 2<br />0 0 0<br />7 0 8</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">9 0 0<br />0 0 8<br />2 0 0</td>
</tr><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">0 0 2<br />8 0 0<br />0 0 5</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">6 0 9<br />2 0 3<br />0 1 0</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">5 0 0<br />0 0 9<br />3 0 0</td>
</tr></tbody></table></td>
<td width="50"><img src="./Problem 96 - Project Euler_files/spacer.gif" width="50" height="1" alt="" /><br /></td>
<td>
<table cellpadding="5" cellspacing="0" border="1"><tbody><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">4 8 3<br />9 6 7<br />2 5 1</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">9 2 1<br />3 4 5<br />8 7 6</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">6 5 7<br />8 2 1<br />4 9 3</td>
</tr><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">5 4 8<br />7 2 9<br />1 3 6</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">1 3 2<br />5 6 4<br />7 9 8</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">9 7 6<br />1 3 8<br />2 4 5</td>
</tr><tr><td style="font-family:&#39;courier new&#39;;font-size:14pt;">3 7 2<br />8 1 4<br />6 9 5</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">6 8 9<br />2 5 3<br />4 1 7</td>
<td style="font-family:&#39;courier new&#39;;font-size:14pt;">5 1 4<br />7 6 9<br />3 8 2</td>
</tr></tbody></table></td>
</tr></tbody></table></div>

<p>A well constructed Su Doku puzzle has a unique solution and can be solved by logic, although it may necessary to employ “guess and test” methods in order to eliminate options (there is much contested opinion over this). The complexity of the search determines the difficulty of the puzzle; the example above is considered <em>easy</em> because it can be solved by straight forward direct deduction.</p>

<p>The 6K text file, <a href="https://projecteuler.net/project/resources/p096_sudoku.txt">sudoku.txt</a> (right click and ‘Save Link/Target As…’), contains fifty different Su Doku puzzles ranging in difficulty, but all with unique solutions (the first puzzle in the file is the example above).</p>

<p>By solving all fifty puzzles find the sum of the 3-digit numbers found in the top left corner of each solution grid; for example, 483 is the 3-digit number found in the top left corner of the solution grid above.</p>

<h2 id="answer">Answer</h2>

<p>Okay, so we are just making a sudoku solver. To recap, each row, column and 3 by 3 box must contain all the digits 1-9 <strong>exactly once</strong>. How do we begin to code up a solution?</p>

<p>The second paragraph provides a good clue. Most puzzles can be solved by logic. I suggest you take a pen and paper and attempt to solve the example above. Pay close attention to your thinking process as you solve it. Chances are, you’ll think something similar to “This cell can’t have a 2 because there’s a 2 already in the row”, or “This cell needs to be a 5, which makes this other cell an 8, and etc.” <em>That thought process is what we want to capture!</em></p>

<p>First, we would need for each cell, which other cells in the grid constrain the result of the cell. In this case, it would always be, the 8 other cells in its row, the 8 cells in its column, and the remaining 4 cells in the box the cell is part of. As our program evolves, we keep updating of the possible numbers that can go in each cell. We also need methods that update the possibilities through pure logic, and also ones that brute force checks the remaining cells which haven’t been narrowed down (what the problem calls “guess and test”). So our steps are:</p>

<ul>
  <li><strong>Initially, each 0 cell will have all possibilities.</strong> The cells that have been filled in are already solved.</li>
  <li><strong>Reduce possibilities through logic.</strong> This is analogous to the thought process “This cell can’t be an 8 because there’s an 8 in the column.” Any cell which has been narrowed down completely to only one option <strong>gets filled in.</strong> This prior step actually trims down our search space tremendously, as the easy puzzles are usually solved by this point actually.</li>
  <li><strong>Of those cells which still have more than one possibility, brute force them</strong>. Simply what you would do in real life: Fill in an option, and try to solve the puzzle from there. If we reach an impossibility (a cell has 0 options as to what number it could contain), then the choice was wrong, and so we erase and fill in our next choice. <strong>Step 2 takes place once we’ve filled in an option as well</strong>.</li>
  <li>Keep going, until each cell has only one option, in which case the puzzle is solved.</li>
</ul>

<p>The structure I’m using to store the possibilities is a three dimensional list. We have a 9 by 9 grid, where each element is a list of the numbers the cell can be. We assume the board itself is also a two dimensional list. As you might guess from the methodology, the main solver method is <strong>recursive</strong>. With recursion involving lists, we have to be extra careful. Python does shallow copies of lists if we assign 2 separate variables to it, so when you change one it changes the other. This causes problems when we backtrack because we’ll lose the original board. To solve it, I use the <code class="highlighter-rouge">deepcopy</code> method from the <code class="highlighter-rouge">copy</code> package, which completely creates a new object. Additionally, to iterate through the indices, I use <code class="highlighter-rouge">itertools.product</code>, which conveniently returns tuples <code class="highlighter-rouge">(0,0), (0,1), ...</code> given a <code class="highlighter-rouge">repeat</code> parameter.</p>

<p>The code is longer than most due to all the methods, but it is still digestable.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getConstraintSets</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">blockSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">constraintSet</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Row set
</span>        <span class="n">s</span><span class="p">.</span><span class="n">extend</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="c1"># Column set
</span>        <span class="n">s</span><span class="p">.</span><span class="n">extend</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="c1"># Block set
</span>        <span class="c1"># Get top corner of block (0-index)
</span>        <span class="n">blockRow</span> <span class="o">=</span> <span class="n">r</span> <span class="o">//</span> <span class="n">blockSize</span> <span class="o">*</span> <span class="n">blockSize</span>
        <span class="n">blockColumn</span> <span class="o">=</span> <span class="n">c</span> <span class="o">//</span> <span class="n">blockSize</span> <span class="o">*</span> <span class="n">blockSize</span>
        <span class="c1"># Iterate through the block...
</span>        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blockRow</span><span class="p">,</span> <span class="n">blockRow</span> <span class="o">+</span> <span class="n">blockSize</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blockColumn</span><span class="p">,</span> <span class="n">blockColumn</span> <span class="o">+</span> <span class="n">blockSize</span><span class="p">):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span>
        <span class="c1"># Get rid of duplicates
</span>        <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="c1"># Remove the cell we're at...
</span>        <span class="n">s</span><span class="p">.</span><span class="n">remove</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="n">constraintSet</span><span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">constraintSet</span>


<span class="k">def</span> <span class="nf">initialPossibilities</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">poss</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Need to make a new list object each
</span>    <span class="c1"># time.
</span>    <span class="k">return</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">poss</span><span class="p">)</span> <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span> 
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>


<span class="c1"># Method to directly deduce the number of possibilities
# as much as possible without resorting to checking
# multiple values for a single cell i.e. PURE
# DEDUCTION
</span><span class="k">def</span> <span class="nf">reducePossibilities</span><span class="p">(</span><span class="n">posses</span><span class="p">,</span> <span class="n">constraintSets</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">possibilities</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">posses</span><span class="p">)</span>
    <span class="n">solvedCells</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">solvedCells</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">solvedCells</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Get the value
</span>        <span class="c1"># If the list is empty,
</span>        <span class="c1"># that means there are no possibilities
</span>        <span class="c1"># in this cell...
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># For each cell in the constrained set,
</span>        <span class="c1"># go to that cell, and remove 'value' from
</span>        <span class="c1"># that cell's list of possibilities.
</span>        <span class="k">for</span> <span class="n">consR</span><span class="p">,</span> <span class="n">consC</span> <span class="ow">in</span> <span class="n">constraintSets</span><span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">[</span><span class="n">consR</span><span class="p">][</span><span class="n">consC</span><span class="p">]:</span>
                <span class="n">possibilities</span><span class="p">[</span><span class="n">consR</span><span class="p">][</span><span class="n">consC</span><span class="p">].</span><span class="n">remove</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="c1"># If it resulted in one possibility, then
</span>                <span class="c1"># it's "solved". Add it to the list to check
</span>                <span class="c1"># later.
</span>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">[</span><span class="n">consR</span><span class="p">][</span><span class="n">consC</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">solvedCells</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">consR</span><span class="p">,</span> <span class="n">consC</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">possibilities</span>


<span class="c1"># Recursive function to handle
# nonpure deductions...
</span><span class="k">def</span> <span class="nf">solveBoard</span><span class="p">(</span><span class="n">possibilities</span><span class="p">,</span> <span class="n">constraintSets</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="c1"># Board is solved if we have exactly
</span>    <span class="c1"># one possibility in each cell.
</span>    <span class="k">if</span> <span class="n">isSolved</span><span class="p">(</span><span class="n">possibilities</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="c1"># Get the next cell with a 0
</span>    <span class="c1"># in it a.k.a has more than one possibility
</span>    <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getNext0</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
    <span class="c1"># For each choice we have,
</span>    <span class="c1"># try it, reduce the possibilities
</span>    <span class="c1"># and see if it will work...
</span>    <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
        <span class="c1"># Copy the possibilities list
</span>        <span class="n">testPoss</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
        <span class="n">testPoss</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">choice</span><span class="p">]</span>
        <span class="c1"># Reduction...
</span>        <span class="n">reduction</span> <span class="o">=</span> <span class="n">reducePossibilities</span><span class="p">(</span><span class="n">testPoss</span><span class="p">,</span> <span class="n">constraintSets</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="c1"># If it's a failed reduction, throw it away,
</span>        <span class="c1"># Otherwise, assume it's right and try to
</span>        <span class="c1"># solve the board from that spot.
</span>        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">solveBoard</span><span class="p">(</span><span class="n">reduction</span><span class="p">,</span> <span class="n">constraintSets</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="c1"># If something came back other than None,
</span>            <span class="c1"># then it was solved!
</span>            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">getNext0</span><span class="p">(</span><span class="n">possibilities</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibilities</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">isSolved</span><span class="p">(</span><span class="n">posses</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">posses</span><span class="p">)),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">posses</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>


<span class="n">N</span> <span class="o">=</span> <span class="mi">9</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'p096_sudoku.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">boardText</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>
<span class="n">boards</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardText</span><span class="p">),</span> <span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Read the next 9 lines into the board...
</span>    <span class="n">boards</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">boardText</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]])</span>

<span class="c1"># Split each line into the individual numbers and apply a cast
# There are 50 boards so reshape as well
</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">constSets</span> <span class="o">=</span> <span class="n">getConstraintSets</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="k">for</span> <span class="n">board</span> <span class="ow">in</span> <span class="n">boards</span><span class="p">:</span>
    <span class="c1"># Get initial possibilities and
</span>    <span class="c1"># reduce them.
</span>    <span class="n">initial</span> <span class="o">=</span> <span class="n">initialPossibilities</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="c1"># prettyPrintBoard(initial)
</span>    <span class="n">reduced</span> <span class="o">=</span> <span class="n">reducePossibilities</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">constSets</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">solved</span> <span class="o">=</span> <span class="n">solveBoard</span><span class="p">(</span><span class="n">reduced</span><span class="p">,</span> <span class="n">constSets</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="c1"># Add the top 3 corner numbers...
</span>    <span class="n">s</span> <span class="o">+=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">solved</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">solved</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">solved</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>Running this very long code gets a final sum of,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>24702
1.5998253 seconds.
</code></pre></div></div>

<p>Thus, our sum is <strong>24702</strong>. The time is not bad at all, especially considering that the final puzzles in the list have the bare minimum of filled-in squares (17) necessary to solve.</p>
:ET