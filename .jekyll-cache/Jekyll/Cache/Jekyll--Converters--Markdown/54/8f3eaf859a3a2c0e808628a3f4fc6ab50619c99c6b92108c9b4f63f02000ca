I"4.<h2 id="question">Question</h2>

<p>If \(p\) is the perimeter of a right angle triangle with integral length sides, \(\{a,b,c\}\), there are exactly three solutions for \(p = 120\).</p>

\[\begin{aligned}
\{20,48,52\},\{24,45,51\},\{30,40,50\}
\end{aligned}\]

<p>For which value of \(p\leq1000\), is the number of solutions maximised?</p>

<h2 id="answer">Answer</h2>

<p>There are two possible we could go about this: Either we test each \(p\) and see which right triangles exist, or we take all right angles with perimeters below 1000 and see which perimeter occurs the most. Personally, I think the latter is the easier way to go, as not every \(p\) will have an integer right triangle associated with it.</p>

<p>So then how do we find all Pythagorean triples with perimeters less than or equal 1000? After some research on methods of generating triples, I came across <a href="https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples">this Wikipedia page</a>, which details 3 matrices which can be used to find all triples. I have reproduced the matrices below.</p>

\[\begin{aligned}
A &amp;= \begin{bmatrix}
	1 &amp; -2 &amp; 2 \\
	2 &amp; -1 &amp; 2 \\
	2 &amp; -2 &amp; 3
\end{bmatrix} \\
B &amp;= \begin{bmatrix}
	1 &amp; 2 &amp; 2 \\
	2 &amp; 1 &amp; 2 \\
	2 &amp; 2 &amp; 3
\end{bmatrix} \\
C &amp;= \begin{bmatrix}
	-1 &amp; 2 &amp; 2 \\
	-2 &amp; 1 &amp; 2 \\
	-2 &amp; 2 &amp; 3
\end{bmatrix}
\end{aligned}\]

<p>To generate triples, start with the most basic of them: (3,4,5). Convert this to a vector \(\mathbf{v}=\langle 3,4,5 \rangle\). Now multiply this vector by one of the three matrices above on the left i.e. \(A\mathbf{v}\). The result of this is another Pythagorean triple! What’s more, each of the three matrices will always get you 3 distinct triples. For example, \(A\mathbf{v}\) will get you the triple \(\langle 5,12,13 \rangle\), while \(B\mathbf{v}=\langle 21,20,29\rangle\) and \(C\mathbf{v}=\langle 15,8,17\rangle\).</p>

<p>Because you get three distinct vectors, you can form almost a kind of tree of Pythagorean triples, depending on the order you multiply matrices. For example, multiplying \(C\), then \(B\), then \(A\) gets you \(ABC\mathbf{v}=\langle 115,252,277\rangle\).</p>

<p>One note I should make is that this method will only generate <strong>primitive</strong> Pythagorean triples, meaning those that are in their reduced form. The triple \(\langle 10,24,26\rangle\) will not be generated in this process, because it is a multiple of \(\langle 5,12,13\rangle\). However, this problem is easily worked around as I will explain later.</p>

<p>Because this is a tree structure, recursion is the perfect method to write a function that generates triples for us. The only thing we need to keep passing is the current triple, and the maximum perimeter we want. If we encounter a triple that is larger than the maximum perimeter allowed, we simply cut the tree at that point. Using <code class="highlighter-rouge">numpy</code> will allow us to easily multiply matrices, and putting it in generator format will mean we won’t have to store all the triples at one time. The recursion step is simple: We simply multiply each matrix by the current triple and start a new branch. See the code below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">genPythagoreanTriples</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">maxP</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="c1"># Base case...
</span>    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxP</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">yield</span> <span class="n">triple</span>
    <span class="c1"># Multiply each matrix
</span>    <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">multTriple</span> <span class="ow">in</span> <span class="n">genPythagoreanTriples</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">triple</span><span class="p">),</span> <span class="n">maxP</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">multTriple</span>
</code></pre></div></div>

<p>At this point, we simply define our \(A,B,\) and \(C\) in the main program, and then calculate the perimeter of each triangle. Recall that the generation method only generates primitive triples. In order to get multiples of triples, we need to loop through all multiples that don’t exceed the perimeter once more. For example, since the (3,4,5) triangle has perimeter 12, and \(\lfloor 1000/12 \rfloor = 83\), we need to go through (3,4,5), (6,8,10), …, (249,332,415). That last triangle has a perimeter of 996, just below our bound. We do this for each primitive triple generated using the function above. We also add each perimeter as it comes along, without worrying about duplicates for the moment.</p>

<p>After we are done going through all triples, we can call <code class="highlighter-rouge">numpy</code>’s <code class="highlighter-rouge">unique</code> function to gather us the unique perimeter values as well as how many times each perimeter was encountered. We can then take the maximum and we’re done!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Make the matrices
</span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">maxP</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">trianglePerims</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">genPythagoreanTriples</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> <span class="n">maxP</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">perimTriple</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span>
    <span class="c1"># Generate all triple multiples that don't exceed maxP
</span>    <span class="c1"># and add it to the list
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxP</span> <span class="o">//</span> <span class="n">perimTriple</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trianglePerims</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">perimTriple</span><span class="p">)</span>

<span class="c1"># Find the unique solutions
</span><span class="n">unique</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">trianglePerims</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Find the p with the most solutions
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">unique</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">count</span><span class="p">)],</span> <span class="s">'has'</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="n">count</span><span class="p">),</span> <span class="s">'solutions.'</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice I used <code class="highlighter-rouge">np.argmax()</code> to get the <em>location</em> of the maximum solutions. Running the code results in an output of,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p = 840 has 8 solutions.
0.0012768364795974804 seconds.
</code></pre></div></div>

<p>Therefore, \(p=\boxed{840}\) is the perimeter with the most solutions (8). It took almost no time at all since we only had to look through all triples whose perimeter was at most 1000 (~350 of them).</p>
:ET