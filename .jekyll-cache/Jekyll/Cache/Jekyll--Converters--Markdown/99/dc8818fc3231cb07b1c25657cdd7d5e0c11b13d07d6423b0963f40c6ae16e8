I"@<h2 id="question">Question</h2>

<p>Each character on a computer is assigned a unique code and the  preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and  lowercase k = 107.</p>

<p>A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.</p>

<p>For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both “halves”, it is impossible to decrypt the message.</p>

<p>Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.</p>

<p>Your task has been made easy, as the encryption key consists of three lower case characters. Using <a href="https://projecteuler.net/project/resources/p059_cipher.txt">p059_cipher.txt</a>  (right click and ‘Save Link/Target As…’), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.</p>

<h2 id="answer">Answer</h2>

<p>Something different this time in the realm of cryptography. It seems pretty straightforward: Try every combination of three lowercase letters, decrypt the message, and see if it makes sense. However, there’s a couple of problems here:</p>

<ul>
  <li>All combinations of three lowercase letters is \(26^3 = 17\,576\), which might not be too bad in this problem, but can get unruly if we have any more letters.</li>
  <li>What on earth does “if it makes sense” mean? Sure, it means “the excerpt is read properly and is legible”, but how do we translate that into logic?</li>
</ul>

<p>For the first bullet point, we can take this approach: Since the sequence of three letters will be repeated, that means each letter in the key will decrypt every <strong>third</strong> letter in the encrypted message. We can see if every third letter is indeed a letter, digit, or special character. As an example, say the first letter of a test key is ‘b’. If when decrypting every third letter in the encrypted message (starting from the first one) results in strange characters that can’t possibly be part of regular words, then we know all keys starting with ‘b’ are invalid! In this way, we reduce the number of possible characters in each position of the key to something much less than \(26^3\).</p>

<p>For the second point, note that the problem says that the text contains common English words. However, another way to say this, is that “letters occur where they are supposed to”, or more quantitatively, <strong>the distribution of the letters in the decrypted text follow closely with that of the English language</strong>. That is something we can compare using code! Now, the distribution of the letters in the English language can be seen at <a href="https://en.wikipedia.org/wiki/Letter_frequency">this Wikipedia page</a>. To measure “closeness”, we can put these values into a vector, and calculate the distance to the letter distribution vector of a decrypted message. The key which produces the smallest distance to the ground truth distribution will be the correct key!</p>

<p>So let’s put this in code. Python provides built-in functions <code class="highlighter-rouge">chr()</code> and <code class="highlighter-rouge">ord()</code> which allow us to go back and forth between the character and the integer it represents. To perform an XOR operation between two integers, we use the <code class="highlighter-rouge">^</code> operator (“Oh so that’s what the carat is used for!” :)). In that first for loop, I check to see the possible letters in each position of the key. Any character with an ASCII value less than 32 (32 is space) and greater than 122 is invalid with respect to this problem. I save all possible letters at each position into a double array.</p>

<p>In order to go through combinations then, I use the <code class="highlighter-rouge">product</code> function from the <code class="highlighter-rouge">itertools</code> which gives quick looping. Notice I save the ground truth distribution array as well. Using each possible key, I decrypt the message, filter out anything which aren’t letters, calculate the frequency distribution, and then use <code class="highlighter-rouge">np.linalg.norm</code> to figure out the distance to the ground truth distribution. The least distance and associated key is then saved, which I then use to calculate the sum of all decrypted integers, which is what the problem is asking for. Note the use of the <code class="highlighter-rouge">string</code> package to grab the lowercase letters.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'p059_cipher.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">encryptedMess</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)]</span>

<span class="c1"># Find the only possible letters that could
# be part of the enccryption key.
</span><span class="n">encryptedPosses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">possLetters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">:</span>
        <span class="n">intRep</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
        <span class="c1"># Encrypt every 3rd letter starting
</span>        <span class="c1"># from i...
</span>        <span class="n">decryptedCharas</span> <span class="o">=</span> <span class="p">[</span><span class="n">intRep</span> <span class="o">^</span> <span class="n">encInt</span> <span class="k">for</span> <span class="n">encInt</span> <span class="ow">in</span> <span class="n">encryptedMess</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">]]</span>
        <span class="c1"># All of the decrypted charas have to be
</span>        <span class="c1"># letters, digits, special charas, or spaces.
</span>        <span class="c1"># So integer is between 32 and 122.
</span>        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="mi">32</span> <span class="o">&lt;=</span> <span class="n">charaInt</span> <span class="o">&lt;=</span> <span class="mi">122</span> <span class="k">for</span> <span class="n">charaInt</span> <span class="ow">in</span> <span class="n">decryptedCharas</span><span class="p">):</span>
            <span class="n">possLetters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="n">encryptedPosses</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">possLetters</span><span class="p">)</span>

<span class="c1"># Ground truth frequency for each letter
# in english language (from Wikipedia)
</span><span class="n">groundTruth</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.08167</span><span class="p">,</span> <span class="mf">0.01492</span><span class="p">,</span> <span class="mf">0.02782</span><span class="p">,</span> <span class="mf">0.04253</span><span class="p">,</span> <span class="mf">0.12702</span><span class="p">,</span> <span class="mf">0.02228</span><span class="p">,</span> <span class="mf">0.02015</span><span class="p">,</span>
               <span class="mf">0.06094</span><span class="p">,</span> <span class="mf">0.06966</span><span class="p">,</span> <span class="mf">0.00153</span><span class="p">,</span> <span class="mf">0.00772</span><span class="p">,</span> <span class="mf">0.04025</span><span class="p">,</span> <span class="mf">0.02406</span><span class="p">,</span> <span class="mf">0.06749</span><span class="p">,</span>
               <span class="mf">0.07507</span><span class="p">,</span> <span class="mf">0.01929</span><span class="p">,</span> <span class="mf">0.00095</span><span class="p">,</span> <span class="mf">0.05987</span><span class="p">,</span> <span class="mf">0.06327</span><span class="p">,</span> <span class="mf">0.09056</span><span class="p">,</span> <span class="mf">0.02758</span><span class="p">,</span>
               <span class="mf">0.00978</span><span class="p">,</span> <span class="mf">0.02360</span><span class="p">,</span> <span class="mf">0.00150</span><span class="p">,</span> <span class="mf">0.01974</span><span class="p">,</span> <span class="mf">0.00074</span><span class="p">]</span>
<span class="n">bestKey</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">closestDist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">possibleKey</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">encryptedPosses</span><span class="p">):</span>
    <span class="c1"># Decrypt text given this key
</span>    <span class="n">decryptedText</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">possibleKey</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span> <span class="o">^</span> <span class="n">encryptedMess</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encryptedMess</span><span class="p">))]</span>
    <span class="c1"># Turn everything to lowercase and grab
</span>    <span class="c1"># only letters...
</span>    <span class="n">onlyLetters</span> <span class="o">=</span> <span class="p">[</span><span class="n">chara</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">chara</span> <span class="ow">in</span> <span class="n">decryptedText</span> <span class="k">if</span> <span class="n">chara</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">]</span>
    <span class="c1"># Calculate counts of each letter
</span>    <span class="n">letterCounts</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">onlyLetters</span><span class="p">:</span>
        <span class="n">letterCounts</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Calculate frequency
</span>    <span class="n">letterFreq</span> <span class="o">=</span> <span class="n">letterCounts</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">letterCounts</span><span class="p">)</span>
    <span class="c1"># Calculate distance to ground truth
</span>    <span class="c1"># distribution
</span>    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">letterFreq</span> <span class="o">-</span> <span class="n">groundTruth</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">closestDist</span><span class="p">:</span>
        <span class="n">closestDist</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="n">bestKey</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">possibleKey</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Best key is "{}".'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">bestKey</span><span class="p">))</span>

<span class="c1"># Now decrypt message and add all
# integers...
</span><span class="n">decryptedSum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">ord</span><span class="p">(</span><span class="n">bestKey</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span> <span class="o">^</span> <span class="n">encryptedMess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encryptedMess</span><span class="p">))])</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Sum of decrypted integers: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">decryptedSum</span><span class="p">))</span>
</code></pre></div></div>

<p>Running the entire code above results in an output of,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Best key is "god".
Sum of decrypted integers: 107359
0.07973290677218499 seconds.
</code></pre></div></div>

<p>Therefore, the key to the message is “god” and the sum is <strong>107359</strong>. What’s the decrypted message? I’ll leave it to you :)</p>

<h3 id="update-july-23-2019">Update July 23, 2019</h3>

<p>So after a small revisit to this problem, I discovered that due to the religious nature of the key and decrypted text, the encrypted message has been changed as of February 5, 2019. You will notice that the cipher link above doesn’t produce the respective output above. Instead, it produces,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Best key is "exp".
Sum of decrypted integers: 129448
0.02513697772366312 seconds.
</code></pre></div></div>

<p>Note that there is no change needed in the original program, as the problem itself didn’t change, only the input.</p>
:ET