I".<h2 id="question">Question</h2>

<p>There are exactly ten ways of selecting three from five, 12345:</p>

<p style="text-align:center">
123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
</p>

<p>In combinatorics, we use the notation \(\,_5C_3=10\).</p>

<p>In general \(\,_nC_r=\displaystyle\frac{n!}{r!(n-r)!}\), where \(r\leq n, n!=n\times(n-1)\times\dots\times 3\times 2\times 1\), and \(0!=1\).</p>

<p>It is not until \(n=23\), that a value exceeds one-million: \(\,_{23}C_{10}=1144066\).</p>

<p>How many, not necessarily distinct, values of \(\,_nC_r\) for \(1\leq n\leq 100\), are greater than one-million?</p>

<h2 id="answer">Answer</h2>

<p>Notice that the formula for \(\,_nC_r\) has three factorials. Recomputing each of these factorials each time will be time-consuming and inefficient. Instead, we can find \(n!\) for all \(0\leq n\leq 100\), and grab the values we need for each computation. The reason we start from 0 is because \(0\leq r\leq n\). Python’s <code class="highlighter-rouge">math</code> package has a quick factorial function we can use:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">factorials</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="p">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">101</span><span class="p">)]</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">factorials</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">factorials</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">factorials</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</code></pre></div></div>

<p>Running this short loop results in,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4075
0.0038949089640585117 seconds.
</code></pre></div></div>

<p>Thus, there are <strong>4075</strong> elements that are greater than one-million, and in quick time as well.</p>

<h3 id="alternative-solution">Alternative Solution</h3>

<p>We can actually solve this problem without computing a single factorial! We can use <strong>Pascal’s triangle</strong> to find \(\,_nC_r\), as the rows of the triangle are the values of \(\,_nC_r\). If you’re unfamiliar, Pascal’s triangle is constructed like this:</p>

<ol>
  <li>The first row is \(1\).</li>
  <li>The second row is \(1\quad 1\).</li>
  <li>Each row after the second is formed by placing two ones at the ends, while the middle values are calculated by adding the two numbers above. For example, the first 5 rows are shown below.</li>
</ol>

<pre style="text-align:center">
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
</pre>

<p>If the rows are numbered starting from 0, and the elements in the row are also numbered starting from 0, the \(r^\text{th}\) number in the \(n^\text{th}\) row is exactly \(\,_nC_r\). Using the generative nature of Pascal’s triangle, we can continuously generate each row until the 100th row, and count the numbers which are greater than one-million.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">currRow</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
    <span class="n">nextRow</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nextRow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nextRow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Make the next row
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">currRow</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">nextRow</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">currRow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">currRow</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Count how many are bigger than 1 million
</span>    <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nextRow</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">])</span>
    <span class="n">currRow</span> <span class="o">=</span> <span class="n">nextRow</span>
<span class="k">print</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice we can’t start from the 23rd row anymore; we have to start from the beginning in order to see what the 23rd row is. Regardless, the output of is the same, although slightly faster, since we’re not computing factorials anymore.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4075
0.0015237512804923096 seconds.
</code></pre></div></div>

:ET